import JsPsychHTMLKeyboardResponse from '@jspsych/plugin-html-keyboard-response';

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// stimuli.json
var require_stimuli = __commonJS({
  "stimuli.json"(exports, module) {
    module.exports = [
      {
        img: "../img/blue.png",
        word: "pope",
        endingPhonetic: "o\u028Ap",
        endingOrthographic: "ope",
        name_agreement: 0.45,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "rope",
        endingPhonetic: "o\u028Ap",
        endingOrthographic: "ope",
        name_agreement: 1,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "soap",
        endingPhonetic: "o\u028Ap",
        endingOrthographic: "oap",
        name_agreement: 0.8,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "bell",
        endingPhonetic: "\u025B\u026B",
        endingOrthographic: "ell",
        name_agreement: 0.9,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "bag",
        endingPhonetic: "\xE6\u0261",
        endingOrthographic: "ag",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "bear",
        endingPhonetic: "\u025B\u0279",
        endingOrthographic: "ear",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "bed",
        endingPhonetic: "\u025Bd",
        endingOrthographic: "ed",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "beer",
        endingPhonetic: "\u026A\u0279",
        endingOrthographic: "eer",
        name_agreement: 0.75,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "bone",
        endingPhonetic: "o\u028An",
        endingOrthographic: "one",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "box",
        endingPhonetic: "\u0251ks",
        endingOrthographic: "ox",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "brain",
        endingPhonetic: "e\u026An",
        endingOrthographic: "ain",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "bread",
        endingPhonetic: "\u025Bd",
        endingOrthographic: "ead",
        name_agreement: 0.9,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "cab",
        endingPhonetic: "\xE6b",
        endingOrthographic: "ab",
        name_agreement: 0.05,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "cat",
        endingPhonetic: "\xE6t",
        endingOrthographic: "at",
        name_agreement: 0.9,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "chain",
        endingPhonetic: "e\u026An",
        endingOrthographic: "ain",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "chair",
        endingPhonetic: "\u025B\u0279",
        endingOrthographic: "air",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "claw",
        endingPhonetic: "\u0254",
        endingOrthographic: "aw",
        name_agreement: 0.55,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "clock",
        endingPhonetic: "\u0251k",
        endingOrthographic: "ock",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "cone",
        endingPhonetic: "o\u028An",
        endingOrthographic: "one",
        name_agreement: 0.7,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "crab",
        endingPhonetic: "\xE6b",
        endingOrthographic: "ab",
        name_agreement: 0.95,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "crane",
        endingPhonetic: "e\u026An",
        endingOrthographic: "ane",
        name_agreement: 0.7,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "dart",
        endingPhonetic: "\u0251\u0279t",
        endingOrthographic: "art",
        name_agreement: 0.9,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "deer",
        endingPhonetic: "\u026A\u0279",
        endingOrthographic: "eer",
        name_agreement: 0.65,
        target_frequency: 3.681
      },
      {
        img: "../img/blue.png",
        word: "door",
        endingPhonetic: "\u0254\u0279",
        endingOrthographic: "oor",
        name_agreement: 0.95,
        target_frequency: 3.681
      }
    ];
  }
});
var stimuli = require_stimuli();
function buildPairingMap() {
  let pairingMap = [];
  for (let i = 0; i < stimuli.length; i++) {
    for (let j = 0; j < stimuli.length; j++) {
      if (pairingMap.map((item) => item.words).includes(`${stimuli[j].word}-${stimuli[i].word}`) || i === j) {
        continue;
      } else {
        pairingMap.push(
          {
            words: `${stimuli[i].word}-${stimuli[j].word}`,
            pairing: [stimuli[i], stimuli[j]],
            phonetics: [stimuli[i].endingPhonetic, stimuli[j].endingPhonetic],
            orthographics: [stimuli[i].endingOrthographic, stimuli[j].endingOrthogaphic],
            html: `<div style='display:flex;align-items:center;justify-content:center;'> 
                            <img src=${stimuli[i].img} style='width:50'></img>
                            <p>+</p>
                            <img src=${stimuli[j].img} style='width:50'></img>
                        </div>`,
            // problem with the stimuli not appearing side-by-side
            // set this up so that stimuli are randomized left/right; this might end up refactoring the html in the grabStimuli function
            rhymePhonetic: stimuli[i].endingPhonetic === stimuli[j].endingPhonetic ? true : false,
            rhymeOrthographic: stimuli[i].endingOrthographic === stimuli[j].endingOrthographic ? true : false
          }
        );
      }
    }
  }
  console.log(pairingMap);
  return pairingMap;
}
function grabStimuli(pairingMap, phonetic, rhymePhonetic, rhymeOrthographic) {
  console.log(`Variables are ${phonetic}, ${rhymePhonetic}, ${rhymeOrthographic}`);
  var pairings = pairingMap.filter((item) => item.phonetics.includes(phonetic));
  console.log(pairings);
  if (rhymePhonetic === true) {
    pairings = pairings.filter((item) => item.rhymePhonetic === true);
    if (rhymeOrthographic === true) {
      pairings = pairings.filter((item) => item.rhymeOrthographic === true);
    } else {
      pairings = pairings.filter((item) => item.rhymeOrthographic === false);
    }
  } else {
    pairings = pairings.filter((item) => item.rhymePhonetic === false);
  }
  console.log(pairings);
  const trialStimulus = pairings[Math.floor(Math.random() * pairings.length)];
  console.log(trialStimulus.words);
  return trialStimulus.html;
}
function checkOptions(options, phoneticsRhyme, orthographicsRhyme) {
  if (options.percentPhonetic + options.percentOrtho > 1) {
    throw new Error(`
The sum of percentPhonetic and percentOrtho cannot exceed 1.
Please adjust these parameters accordingly.
        `);
  }
  if (phoneticsRhyme.length == 0 && options.percentPhonetic > 0) {
    console.warn(`
Your stimuli.json file does not contain any phonetic rhymes, even though you requested trials with phonetic rhymes.
Please either add stimuli that rhyme phonetically to stimuli.json, or set percentPhonetic to 0 to avoid this warning.
For now, we will make up the difference with non-rhyming trials.
        `);
    options.percentPhonetic = 0;
  }
  if (orthographicsRhyme.length == 0 && options.percentOrtho > 0) {
    console.warn(`
Your stimuli.json file does not contain any orthographic rhymes, even though you requested trials with orthographic rhymes.
Please either add stimuli that rhyme orthographic to stimuli.json, or set percentOrthographic to 0 to avoid this warning.
For now, we will make up the difference with non-rhyming trials.
        `);
    options.percentOrtho = 0;
  }
  if (options.percentOrtho * options.numTrials > orthographicsRhyme.length) {
    console.warn(`
Your stimuli.json file only contains ${orthographicsRhyme.length} unique orthographic rhymes, but you requested ${options.percentOrtho * options.numTrials} orthographic rhymes.
Please either reduce the number of total trials, or reduce the proportion of trials with orthographic rhymes.
For now, we will make up the difference with duplicates.
        `);
  }
  if (options.percentPhonetic * options.numTrials > phoneticsRhyme.length) {
    console.warn(`
Your stimuli.json file only contains ${phoneticsRhyme.length} unique phonetic rhymes, but you requested ${options.percentPhonetic * options.numTrials} phonetic rhymes.
Please either reduce the number of total trials, or reduce the proportion of trials with phonetic rhymes.
For now, we will make up the difference with duplicates.
        `);
  }
  return options;
}
function buildTimelineVariables(pairingMap, options) {
  console.log("building timeline variables");
  var timelineVariables = [];
  var phonetics = stimuli.reduce(
    (accumulator, currentValue) => {
      if (!accumulator.map((item) => item).includes(currentValue.endingPhonetic)) {
        accumulator.push(currentValue.endingPhonetic);
      }
      return accumulator;
    },
    []
  );
  if (options.hasOwnProperty("phoneticWeights")) {
    for (let i = 0; i < Object.keys(options.phoneticWeights).length; i++) {
      const endingWeighted = Object.keys(options.phoneticWeights)[i];
      while (phonetics.filter((ending) => ending === endingWeighted).length < options.phoneticWeights[endingWeighted]) {
        phonetics.push(endingWeighted);
      }
    }
  }
  var rhymesPhonetic = pairingMap.filter((item) => item.rhymePhonetic === true && item.rhymeOrthographic === false);
  rhymesPhonetic = rhymesPhonetic.reduce(
    (accumulator, currentValue) => {
      if (!accumulator.map((item) => item).includes(currentValue.phonetics[0])) {
        accumulator.push(currentValue.phonetics[0]);
      }
      return accumulator;
    },
    []
  );
  if (options.hasOwnProperty("phoneticWeights")) {
    for (let i = 0; i < Object.keys(options.phoneticWeights).length; i++) {
      const endingWeighted = Object.keys(options.phoneticWeights)[i];
      while (rhymesPhonetic.filter((ending) => ending === endingWeighted).length < options.phoneticWeights[endingWeighted]) {
        rhymesPhonetic.push(endingWeighted);
      }
    }
  }
  console.log(`Phonetic rhymes available: ${rhymesPhonetic}`);
  var rhymesOrthographic = pairingMap.filter((item) => item.rhymeOrthographic === true);
  rhymesOrthographic = rhymesOrthographic.reduce(
    (accumulator, currentValue) => {
      if (!accumulator.map((item) => item).includes(currentValue.phonetics[0])) {
        accumulator.push(currentValue.phonetics[0]);
      }
      return accumulator;
    },
    []
  );
  if (options.hasOwnProperty("phoneticWeights")) {
    for (let i = 0; i < Object.keys(options.phoneticWeights).length; i++) {
      const endingWeighted = Object.keys(options.phoneticWeights)[i];
      while (rhymesOrthographic.filter((ending) => ending === endingWeighted).length < options.phoneticWeights[endingWeighted]) {
        rhymesOrthographic.push(endingWeighted);
      }
    }
  }
  console.log(`Orthographic rhymes available: ${rhymesOrthographic}`);
  options = checkOptions(
    options,
    rhymesPhonetic,
    rhymesOrthographic
  );
  var numPhonetic = options.percentPhonetic * options.numTrials;
  var numOrthographic = options.percentOrtho * options.numTrials;
  var numControl = options.numTrials - (numPhonetic + numOrthographic);
  console.log(`I want ${numPhonetic} phonetic rhymes and ${numOrthographic} orthographic rhymes`);
  var selectedOrthographics = rhymesOrthographic.sort(() => 0.5 - Math.random()).slice(0, numOrthographic);
  while (selectedOrthographics.length < numOrthographic) {
    numOrthographic = numOrthographic - selectedOrthographics.length;
    selectedOrthographics = selectedOrthographics.concat(rhymesOrthographic.sort(() => 0.5 - Math.random()).slice(0, numOrthographic));
  }
  const variablesOrthographic = selectedOrthographics.map((item) => ({
    endingPhonetic: item,
    rhymePhonetic: true,
    // assumes every orthographic rhyme is also a phonetic rhyme
    rhymeOrthographic: true
  }));
  if (!options.duplicatesAllowed) {
    rhymesPhonetic = rhymesPhonetic.filter((item) => !selectedOrthographics.includes(item));
  }
  var selectedPhonetics = rhymesPhonetic.sort(() => 0.5 - Math.random()).slice(0, numPhonetic);
  while (selectedPhonetics.length < numPhonetic) {
    numPhonetic = numPhonetic - selectedPhonetics.length;
    selectedPhonetics = selectedPhonetics.concat(rhymesPhonetic.sort(() => 0.5 - Math.random()).slice(0, numPhonetic));
  }
  const variablesPhonetic = selectedPhonetics.map((item) => ({
    endingPhonetic: item,
    rhymePhonetic: true,
    rhymeOrthographic: false
    // this may not always be true, if the only available phonetic rhymes are also orthographic rhymes
  }));
  if (!options.duplicatesAllowed) {
    phonetics = phonetics.filter((item) => !selectedPhonetics.includes(item) && !selectedOrthographics.includes(item));
  }
  var controlSelected = phonetics.sort(() => 0.5 - Math.random()).slice(0, numControl);
  while (controlSelected.length < numControl) {
    numControl = numControl - controlSelected.length;
    controlSelected = controlSelected.concat(phonetics.sort(() => 0.5 - Math.random()).slice(0, numControl));
  }
  const variablesControl = controlSelected.map((item) => ({
    endingPhonetic: item,
    rhymePhonetic: false,
    rhymeOrthographic: false
  }));
  timelineVariables = variablesControl.concat(variablesPhonetic, variablesOrthographic);
  console.log(timelineVariables);
  console.log("done");
  return timelineVariables;
}
function createTimeline(jsPsych, options = {}) {
  var main_timeline = [];
  const defaultOptions = {
    numTrials: 10,
    // this parameter bugs when percentPhonetic or percentOrtho can't be met by available stimuli
    duplicatesAllowed: false,
    percentPhonetic: 0.5,
    percentOrtho: 0.3
  };
  options = __spreadValues(__spreadValues({}, defaultOptions), options);
  const pairingMap = buildPairingMap();
  let variables = buildTimelineVariables(pairingMap, options);
  const trial = {
    type: JsPsychHTMLKeyboardResponse,
    stimulus: () => grabStimuli(
      pairingMap,
      jsPsych.evaluateTimelineVariable("endingPhonetic"),
      jsPsych.evaluateTimelineVariable("rhymePhonetic"),
      jsPsych.evaluateTimelineVariable("rhymeOrthographic")
    ),
    prompt: `<p>Do the names of these items rhyme?</p></br>
                <p>Press F for "Yes" and J for "No"</p>`,
    choices: ["f", "j"]
  };
  var trial_timeline = {
    timeline: [trial],
    timeline_variables: variables,
    randomize_order: false
  };
  main_timeline.push(trial_timeline);
  return main_timeline;
}
var timelineUnits = {};
var utils = {};

export { createTimeline, timelineUnits, utils };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map